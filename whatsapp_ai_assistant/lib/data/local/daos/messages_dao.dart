import 'package:drift/drift.dart';
import 'package:whatsapp_ai_assistant/data/local/app_database.dart'; // Ensure correct path
import 'package:logger/logger.dart'; // Import logger

part 'messages_dao.g.dart'; // Generated by drift_dev

final Logger _logger = Logger();

@DriftAccessor(for: [Messages])
class MessagesDao extends DatabaseAccessor<AppDatabase> with _$MessagesDaoMixin {
  MessagesDao(AppDatabase attachedDatabase) : super(attachedDatabase); // Use super parameter

  // CRUD operations
  Future<List<Message>> getMessagesForConversation(String conversationId) {
    _logger.d('Fetching messages for conversation ID: $conversationId');
    return (select(messages)..where((tbl) => tbl.conversationId.equals(conversationId))).get();
  }

  Future<void> insertMessage(MessagesCompanion entry) {
    _logger.d('Inserting message: ${entry.id.value}');
    return into(messages).insert(entry);
  }

  Future<bool> updateMessage(MessagesCompanion entry) {
    _logger.d('Updating message: ${entry.id.value}');
    return update(messages).replace(entry);
  }

  Future<int> deleteMessage(String id) {
    _logger.d('Deleting message with ID: $id');
    return (delete(messages)..where((tbl) => tbl.id.equals(id))).go();
  }

  Stream<List<Message>> watchMessagesForConversation(String conversationId) {
    _logger.d('Watching messages for conversation ID: $conversationId');
    return (select(messages)..where((tbl) => tbl.conversationId.equals(conversationId))).watch();
  }

  Future<List<Message>> getMessagesForConversation(String conversationId, {int limit = 10, int offset = 0}) {
    _logger.d('Fetching messages for conversation ID: $conversationId (limit: $limit, offset: $offset)');
    return (select(messages)
      ..where((tbl) => tbl.conversationId.equals(conversationId))
      ..orderBy([(tbl) => OrderingTerm.desc(tbl.timestamp)])
      ..limit(limit, offset: offset))
        .get();
  }

  Future<List<Message>> getRecentMessagesForConversation(String conversationId, int limit) {
    _logger.d('Fetching recent messages for conversation ID: $conversationId (limit: $limit)');
    return (select(messages)
      ..where((tbl) => tbl.conversationId.equals(conversationId))
      ..orderBy([(tbl) => OrderingTerm.desc(tbl.timestamp)])
      ..limit(limit))
        .get();
  }
}