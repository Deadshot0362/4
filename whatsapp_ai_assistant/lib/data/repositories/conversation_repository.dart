import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:logger/logger.dart';
import 'package:drift/drift.dart' hide Column; // Hide Column to avoid conflict with Flutter's Column
import 'package:whatsapp_ai_assistant/data/local/app_database.dart';
import 'package:whatsapp_ai_assistant/data/local/daos/conversations_dao.dart';
import 'package:whatsapp_ai_assistant/features/conversation_history/domain/entities/conversation_entity.dart';

part 'conversation_repository.g.dart'; // Generated by riverpod_generator

final Logger _logger = Logger();

@Riverpod(keepAlive: true)
ConversationRepository conversationRepository(ConversationRepositoryRef ref) {
  final appDatabase = ref.watch(appDatabaseProvider); // Access the database via provider
  return ConversationRepository(appDatabase.conversationsDao); // Pass the DAO
}

class ConversationRepository {
  final ConversationsDao _conversationsDao;

  ConversationRepository(this._conversationsDao);

  Future<List<ConversationEntity>> getAllConversations() async {
    _logger.d('Fetching all conversations from repository.');
    try {
      final conversations = await _conversationsDao.getAllConversations();
      // Map drift models to domain entities
      return conversations.map((e) => ConversationEntity.fromDriftConversation(e)).toList();
    } catch (e, stack) {
      _logger.e('Error getting all conversations: $e', error: e, stackTrace: stack);
      throw Exception('Failed to get all conversations: $e');
    }
  }

  Future<ConversationEntity?> getConversationById(String id) async {
    _logger.d('Fetching conversation by ID: $id');
    try {
      final conversation = await _conversationsDao.getConversationById(id);
      return conversation != null ? ConversationEntity.fromDriftConversation(conversation) : null;
    } catch (e, stack) {
      _logger.e('Error getting conversation by ID: $e', error: e, stackTrace: stack);
      throw Exception('Failed to get conversation by ID: $e');
    }
  }

  Future<void> saveConversation(ConversationEntity conversation) async {
    _logger.d('Saving conversation: ${conversation.id}');
    try {
      final companion = ConversationsCompanion(
        id: Value(conversation.id),
        name: Value(conversation.name),
        isMonitored: Value(conversation.isMonitored), // Use Value for `isMonitored`
        lastMessageTime: Value(conversation.lastMessageTime),
      );
      await _conversationsDao.insertConversation(companion);
    } catch (e, stack) {
      _logger.e('Error saving conversation: $e', error: e, stackTrace: stack);
      throw Exception('Failed to save conversation: $e');
    }
  }

  Future<bool> updateConversation(ConversationEntity conversation) async {
    _logger.d('Updating conversation: ${conversation.id}');
    try {
      final companion = ConversationsCompanion(
        id: Value(conversation.id),
        name: Value(conversation.name),
        isMonitored: Value(conversation.isMonitored), // Use Value for `isMonitored`
        lastMessageTime: Value(conversation.lastMessageTime),
      );
      return await _conversationsDao.updateConversation(companion);
    } catch (e, stack) {
      _logger.e('Error updating conversation: $e', error: e, stackTrace: stack);
      throw Exception('Failed to update conversation: $e');
    }
  }

  Future<int> deleteConversation(String id) async {
    _logger.d('Deleting conversation with ID: $id');
    try {
      return await _conversationsDao.deleteConversation(id);
    } catch (e, stack) {
      _logger.e('Error deleting conversation: $e', error: e, stackTrace: stack);
      throw Exception('Failed to delete conversation: $e');
    }
  }

  Stream<List<ConversationEntity>> watchMonitoredConversations() {
    _logger.d('Watching monitored conversations in repository.');
    return _conversationsDao.watchMonitoredConversations().map(
      (conversations) => conversations.map((e) => ConversationEntity.fromDriftConversation(e)).toList(),
    );
  }
}